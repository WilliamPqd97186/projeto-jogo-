#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define MAX_PECA 20
#define MAX_FILA 10
#define MAX_PILHA 5

// -----------------------------
// Estruturas
// -----------------------------
typedef struct {
    char nome[MAX_PECA];
} Peca;

// Fila (FIFO)
typedef struct {
    Peca itens[MAX_FILA];
    int frente, tras, tamanho;
} Fila;

// Pilha (LIFO)
typedef struct {
    Peca itens[MAX_PILHA];
    int topo;
} Pilha;

// -----------------------------
// FunÃ§Ãµes de Fila
// -----------------------------
void inicializarFila(Fila *f) {
    f->frente = 0;
    f->tras = -1;
    f->tamanho = 0;
}

int filaVazia(Fila *f) {
    return f->tamanho == 0;
}

int filaCheia(Fila *f) {
    return f->tamanho == MAX_FILA;
}

void enfileirar(Fila *f, Peca p) {
    if (filaCheia(f)) {
        printf("âš ï¸ Fila de peÃ§as futuras cheia!\n");
        return;
    }
    f->tras = (f->tras + 1) % MAX_FILA;
    f->itens[f->tras] = p;
    f->tamanho++;
}

Peca desenfileirar(Fila *f) {
    Peca p = {"--"};
    if (filaVazia(f)) {
        printf("âŒ Fila vazia!\n");
        return p;
    }
    p = f->itens[f->frente];
    f->frente = (f->frente + 1) % MAX_FILA;
    f->tamanho--;
    return p;
}

void mostrarFila(Fila *f) {
    printf("\nğŸ® PeÃ§as Futuras (Fila):\n");
    if (filaVazia(f)) {
        printf("(vazia)\n");
        return;
    }
    int i = f->frente;
    for (int c = 0; c < f->tamanho; c++) {
        printf("[%s] ", f->itens[i].nome);
        i = (i + 1) % MAX_FILA;
    }
    printf("\n");
}

// -----------------------------
// FunÃ§Ãµes de Pilha
// -----------------------------
void inicializarPilha(Pilha *p) {
    p->topo = -1;
}

int pilhaVazia(Pilha *p) {
    return p->topo == -1;
}

int pilhaCheia(Pilha *p) {
    return p->topo == MAX_PILHA - 1;
}

void empilhar(Pilha *p, Peca nova) {
    if (pilhaCheia(p)) {
        printf("âš ï¸ Pilha de reservas cheia!\n");
        return;
    }
    p->itens[++p->topo] = nova;
}

Peca desempilhar(Pilha *p) {
    Peca peca = {"--"};
    if (pilhaVazia(p)) {
        printf("âŒ Nenhuma peÃ§a reservada!\n");
        return peca;
    }
    return p->itens[p->topo--];
}

void mostrarPilha(Pilha *p) {
    printf("\nğŸ“¦ Pilha de Reservas:\n");
    if (pilhaVazia(p)) {
        printf("(vazia)\n");
        return;
    }
    for (int i = p->topo; i >= 0; i--) {
        printf("[%s]\n", p->itens[i].nome);
    }
}

// -----------------------------
// FunÃ§Ãµes do Jogo
// -----------------------------
void jogarPeca(Fila *f) {
    if (filaVazia(f)) {
        printf("âŒ Nenhuma peÃ§a para jogar!\n");
        return;
    }
    Peca atual = desenfileirar(f);
    printf("ğŸ¯ Jogando peÃ§a: %s\n", atual.nome);
}

void reservarPeca(Fila *f, Pilha *p) {
    if (filaVazia(f)) {
        printf("âŒ Nenhuma peÃ§a para reservar!\n");
        return;
    }
    if (pilhaCheia(p)) {
        printf("âš ï¸ Pilha cheia! Libere espaÃ§o antes de reservar.\n");
        return;
    }
    Peca atual = desenfileirar(f);
    empilhar(p, atual);
    printf("ğŸ’¾ PeÃ§a '%s' foi reservada!\n", atual.nome);
}

void recuperarReserva(Fila *f, Pilha *p) {
    if (pilhaVazia(p)) {
        printf("âŒ Nenhuma peÃ§a reservada para recuperar!\n");
        return;
    }
    Peca recuperada = desempilhar(p);
    printf("ğŸ”„ Recuperando peÃ§a reservada: %s\n", recuperada.nome);
    enfileirar(f, recuperada);
}

// -----------------------------
// FunÃ§Ã£o principal
// -----------------------------
int main() {
    Fila fila;
    Pilha pilha;
    inicializarFila(&fila);
    inicializarPilha(&pilha);

    // PeÃ§as iniciais (simuladas)
    Peca pecas[] = {{"Quadrado"}, {"Linha"}, {"T"}, {"L"}, {"Z"}};
    for (int i = 0; i < 5; i++)
        enfileirar(&fila, pecas[i]);

    int opc;
    do {
        printf("\n=== ğŸ§± TETRIS STACK ===\n");
        printf("1. Mostrar estruturas\n");
        printf("2. Jogar prÃ³xima peÃ§a\n");
        printf("3. Reservar peÃ§a atual\n");
        printf("4. Recuperar peÃ§a reservada\n");
        printf("0. Sair\n> ");
        scanf("%d", &opc);

        switch (opc) {
            case 1:
                mostrarFila(&fila);
                mostrarPilha(&pilha);
                break;
            case 2:
                jogarPeca(&fila);
                break;
            case 3:
                reservarPeca(&fila, &pilha);
                break;
            case 4:
                recuperarReserva(&fila, &pilha);
                break;
            case 0:
                printf("ğŸ‘‹ Encerrando o jogo...\n");
                break;
            default:
                printf("OpÃ§Ã£o invÃ¡lida!\n");
        }
    } while (opc != 0);

    return 0;
}
=== ğŸ§± TETRIS STACK ===
1. Mostrar estruturas
2. Jogar prÃ³xima peÃ§a
3. Reservar peÃ§a atual
4. Recuperar peÃ§a reservada
0. Sair
> 1

ğŸ® PeÃ§as Futuras (Fila):
[Quadrado] [Linha] [T] [L] [Z]

ğŸ“¦ Pilha de Reservas:
(vazia)

> 3
ğŸ’¾ PeÃ§a 'Quadrado' foi reservada!

> 4
ğŸ”„ Recuperando peÃ§a reservada: Quadrado

> 2
ğŸ¯ Jogando peÃ§a: Linha
